<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>WebGL 3D Shapes</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
    }
    button {
      margin: 4px;
      padding: 8px;
    }
  </style>
</head>
<body>
<div id="controls">
  <button onclick="currentShape = 'cylinder'; drawScene();">Cylinder</button>
  <button onclick="currentShape = 'cone'; drawScene();">Cone</button>
  <button onclick="currentShape = 'sphere'; drawScene();">Sphere</button>
  <button onclick="currentShape = 'ellipsoid'; drawScene();">Ellipsoid</button>
  <button onclick="currentShape = 'hyperboloid'; drawScene();">Hyperboloid</button>
  <button onclick="currentShape = 'toroid'; drawScene();">Toroid</button>
</div>
<canvas id="glcanvas"></canvas>
<script>
// [1] INIT CANVAS & GL
const canvas = document.getElementById("glcanvas");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
const gl = canvas.getContext("webgl");

// [2] SHADER PROGRAM
const vsSource = `
  attribute vec3 aPosition;
  attribute vec3 aColor;
  uniform mat4 uModelViewMatrix;
  uniform mat4 uProjectionMatrix;
  varying vec3 vColor;
  void main() {
    gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);
    vColor = aColor;
  }
`;
const fsSource = `
  precision mediump float;
  varying vec3 vColor;
  void main() {
    gl_FragColor = vec4(vColor, 1.0);
  }
`;
function compileShader(type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  return shader;
}
const vertexShader = compileShader(gl.VERTEX_SHADER, vsSource);
const fragmentShader = compileShader(gl.FRAGMENT_SHADER, fsSource);
const program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);
gl.useProgram(program);

// [3] BUFFERS
let positionBuffer = gl.createBuffer();
let colorBuffer = gl.createBuffer();
let indexBuffer = gl.createBuffer();
let currentShape = 'cylinder';

let angleX = 0, angleY = 0;
let dragging = false, lastX, lastY;

canvas.addEventListener("mousedown", e => {
  dragging = true; lastX = e.clientX; lastY = e.clientY;
});
canvas.addEventListener("mouseup", () => dragging = false);
canvas.addEventListener("mousemove", e => {
  if (dragging) {
    angleY += (e.clientX - lastX) * 0.01;
    angleX += (e.clientY - lastY) * 0.01;
    lastX = e.clientX; lastY = e.clientY;
    drawScene();
  }
});

// [4] MATRICES
function getModelViewMatrix() {
  const mv = mat4.create();
  mat4.translate(mv, mv, [0, 0, -6]);
  mat4.rotateX(mv, mv, angleX);
  mat4.rotateY(mv, mv, angleY);
  return mv;
}
function getProjectionMatrix() {
  const p = mat4.create();
  mat4.perspective(p, Math.PI / 4, canvas.width / canvas.height, 0.1, 100);
  return p;
}

// [5] SHAPES
function createSphere() {
  const vertices = [], colors = [], indices = [];
  const latBands = 30, longBands = 30, radius = 1;
  for (let lat = 0; lat <= latBands; lat++) {
    const theta = lat * Math.PI / latBands;
    const sinT = Math.sin(theta), cosT = Math.cos(theta);
    for (let lon = 0; lon <= longBands; lon++) {
      const phi = lon * 2 * Math.PI / longBands;
      const sinP = Math.sin(phi), cosP = Math.cos(phi);
      const x = cosP * sinT, y = cosT, z = sinP * sinT;
      vertices.push(radius * x, radius * y, radius * z);
      colors.push(Math.abs(x), Math.abs(y), Math.abs(z));
    }
  }
  for (let lat = 0; lat < latBands; lat++) {
    for (let lon = 0; lon < longBands; lon++) {
      const a = lat * (longBands + 1) + lon;
      const b = a + longBands + 1;
      indices.push(a, b, a + 1, b, b + 1, a + 1);
    }
  }
  return { vertices, colors, indices };
}
function createEllipsoid() {
  const sphere = createSphere();
  for (let i = 0; i < sphere.vertices.length; i += 3) {
    sphere.vertices[i + 0] *= 1.5;
    sphere.vertices[i + 1] *= 1.0;
    sphere.vertices[i + 2] *= 0.7;
  }
  return sphere;
}
function createHyperboloid() {
  const vertices = [], colors = [], indices = [];
  const rings = 40, slices = 40;
  for (let i = 0; i <= rings; i++) {
    const y = -1 + 2 * i / rings;
    const r = Math.sqrt(1 + y * y);
    for (let j = 0; j <= slices; j++) {
      const theta = 2 * Math.PI * j / slices;
      const x = r * Math.cos(theta);
      const z = r * Math.sin(theta);
      vertices.push(x, y, z);
      colors.push(Math.abs(x / 2), Math.abs(y / 2), Math.abs(z / 2));
    }
  }
  for (let i = 0; i < rings; i++) {
    for (let j = 0; j < slices; j++) {
      const a = i * (slices + 1) + j;
      const b = a + slices + 1;
      indices.push(a, b, a + 1, b, b + 1, a + 1);
    }
  }
  return { vertices, colors, indices };
}
function createToroid() {
  const vertices = [], colors = [], indices = [];
  const R = 1.2, r = 0.4, radial = 40, tubular = 30;
  for (let i = 0; i <= radial; i++) {
    const theta = i * 2 * Math.PI / radial;
    const cosT = Math.cos(theta), sinT = Math.sin(theta);
    for (let j = 0; j <= tubular; j++) {
      const phi = j * 2 * Math.PI / tubular;
      const cosP = Math.cos(phi), sinP = Math.sin(phi);
      const x = (R + r * cosP) * cosT;
      const y = (R + r * cosP) * sinT;
      const z = r * sinP;
      vertices.push(x, y, z);
      colors.push(Math.abs(cosT), Math.abs(sinT), Math.abs(sinP));
    }
  }
  for (let i = 0; i < radial; i++) {
    for (let j = 0; j < tubular; j++) {
      const a = i * (tubular + 1) + j;
      const b = a + tubular + 1;
      indices.push(a, b, a + 1, b, b + 1, a + 1);
    }
  }
  return { vertices, colors, indices };
}

// Cylinder & Cone từ canvas document (giữ nguyên)
function createCylinder() {
  const vertices = [], colors = [], indices = [];
  const height = 2, radius = 1, slices = 40;

  // Bottom circle (y = -1)
  const bottomCenterIndex = 0;
  vertices.push(0, -1, 0);
  colors.push(1, 0, 0); // red bottom
  for (let i = 0; i <= slices; i++) {
    let theta = 2 * Math.PI * i / slices;
    let x = radius * Math.cos(theta);
    let z = radius * Math.sin(theta);
    vertices.push(x, -1, z);
    colors.push(1, 0, 0); // red bottom
    if (i > 0) {
      indices.push(bottomCenterIndex, i, i + 1);
    }
  }

  const offset = vertices.length / 3;

  // Top circle (y = 1)
  const topCenterIndex = offset;
  vertices.push(0, 1, 0);
  colors.push(0, 1, 0); // green top
  for (let i = 0; i <= slices; i++) {
    let theta = 2 * Math.PI * i / slices;
    let x = radius * Math.cos(theta);
    let z = radius * Math.sin(theta);
    vertices.push(x, 1, z);
    colors.push(0, 1, 0); // green top
    if (i > 0) {
      indices.push(topCenterIndex, topCenterIndex + i, topCenterIndex + i + 1);
    }
  }

  const sideOffset = vertices.length / 3;
  // Side
  for (let i = 0; i <= slices; i++) {
    let theta = 2 * Math.PI * i / slices;
    let x = radius * Math.cos(theta);
    let z = radius * Math.sin(theta);
    vertices.push(x, -1, z);
    colors.push(0, 0, 1); // blue side
    vertices.push(x, 1, z);
    colors.push(0, 0, 1); // blue side
    if (i > 0) {
      const idx = sideOffset + (i - 1) * 2;
      indices.push(idx, idx + 1, idx + 2);
      indices.push(idx + 1, idx + 2, idx + 3);
    }
  }

  return { vertices, colors, indices };
}


function createCone() {
  const vertices = [], colors = [], indices = [];
  const height = 2, radius = 1, slices = 40;

  // Bottom circle (y = -1)
  const bottomCenterIndex = 0;
  vertices.push(0, -1, 0);
  colors.push(1, 1, 0); // yellow bottom
  for (let i = 0; i <= slices; i++) {
    let theta = 2 * Math.PI * i / slices;
    let x = radius * Math.cos(theta);
    let z = radius * Math.sin(theta);
    vertices.push(x, -1, z);
    colors.push(1, 1, 0); // yellow bottom
    if (i > 0) {
      indices.push(bottomCenterIndex, i, i + 1);
    }
  }

  const offset = vertices.length / 3;
  const apexIndex = offset;
  vertices.push(0, 1, 0);
  colors.push(1, 0, 1); // magenta side
  for (let i = 0; i <= slices; i++) {
    let theta = 2 * Math.PI * i / slices;
    let x = radius * Math.cos(theta);
    let z = radius * Math.sin(theta);
    vertices.push(x, -1, z);
    colors.push(1, 0, 1); // magenta side
    if (i > 0) {
      indices.push(apexIndex, apexIndex + i, apexIndex + i + 1);
    }
  }

  return { vertices, colors, indices };
}


// [6] RENDER
function drawScene() {
  gl.clearColor(0.95, 0.95, 0.95, 1);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  gl.enable(gl.DEPTH_TEST);

  let shape;
  if (currentShape === 'cylinder') shape = createCylinder();
  else if (currentShape === 'cone') shape = createCone();
  else if (currentShape === 'sphere') shape = createSphere();
  else if (currentShape === 'ellipsoid') shape = createEllipsoid();
  else if (currentShape === 'hyperboloid') shape = createHyperboloid();
  else if (currentShape === 'toroid') shape = createToroid();

  renderShape(shape);
}
function renderShape({ vertices, colors, indices }) {
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
  const posLoc = gl.getAttribLocation(program, "aPosition");
  gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(posLoc);

  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
  const colorLoc = gl.getAttribLocation(program, "aColor");
  gl.vertexAttribPointer(colorLoc, 3, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(colorLoc);

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

  const mvLoc = gl.getUniformLocation(program, "uModelViewMatrix");
  const prLoc = gl.getUniformLocation(program, "uProjectionMatrix");
  gl.uniformMatrix4fv(mvLoc, false, getModelViewMatrix());
  gl.uniformMatrix4fv(prLoc, false, getProjectionMatrix());

  gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
}

// [7] MATRIX LIBRARY
// Load glMatrix: https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js
const script = document.createElement("script");
script.src = "https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js";
script.onload = () => drawScene();
document.head.appendChild(script);
</script>
</body>
</html>
